diff --git a/TP3.md b/TP3.md
new file mode 100644
index 0000000..c540e7a
--- /dev/null
+++ b/TP3.md
@@ -0,0 +1,252 @@
+# static_assert
+
+El static_assert de JOS, hace los chequeos en tiempo de compilacion. De esta forma,
+se lanzara un error de compilacion si la condicion x no se cumple. La forma en que hace esto es
+usando un switch. Si el assert da false, nuestro switch estara compuesto por dos cases iguales
+generando un error de compilacion.
+
+--------
+
+# env_return
+
+-  La secuencia de llamados es la siguiente: El entry point se setea a la direccion de start dentro del archivo asm creado. Esta funcion chequea argumentos, y luego se realiza el llamado a libmain, y una vez aqui se llama al umain correspondiente. Cuando umain termina, se ejecuta ret y se vuelve a la direccion siguiente donde libmain hizo
+el call, llamando asi a exit. Aqui se realiza el llamado a sys_env_destroy, quien llama a syscall con los parametros correspondientes. Una vez desruido el enviroment se vuelve a exit, quien llama a ret y se vuelve a libmain, que luego de esto vuelve a start, que al finalizar devuelve el control al kernel.
+
+- La diferencia mas obvia es que en este TP estamos contemplando el uso de muchos CPUs, lo que nos
+permite correr varios procesos en distintos cores. Para el caso de la funcion env_destroy, esto significa
+que cuando llamemmos a esta funcion, ya no estaremos destruyendo el unico proceso en ejecucion. Si el proceso que recibimos es el que se esta ejecutando se corre un nuevo proceso. Por otro lado, si el proceso que recibimos esta corriendo en otro CPU, generaremos un proceso zombie a traves del estado ENV_DYING que sera liberado la proxima vez que se tope con el kernel.
+
+------------
+
+#envid2env
+
+- Como al pasarle 0 a envid2env recibimos el current enviroment, sys_env_destroy lo va a destruir.
+
+- Se envia la senial 9 a cada proceso en el grupo de procesos de llamada.
+
+- Tendremos un error porque ENVX no permite parametros negativos.
+
+- Se envia la senial 9 a todos los procesos que el proceso que llama tenga permisos para enviar seniales.
+
+------------
+
+# dumbfork
+
+1. No, no se propagará porque cuando estamos haciendo page_alloc alocamos una nueva página, pero no actualizamos nuestra cuenta de páginas. Esto debe hacerlo quien llame a la función. Por lo tanto cuando llamemos a dumbfork, se hará la copia del address space sin tener en cuenta la nueva página alocada.
+
+2. No, no se preserva. De hecho cuando hacemos la copia del address space al proceso hijo, podemos ver en duppage que todos las páginas son mapeadas con permisos de escritura y lectura.
+Código dentro de dumbfork, con addr como parametro:
+
+pde_t actual_PDE = uvpd[PDX(addr)];
+if ((actual_PDE | PTE_P) != actual_PDE) continue;
+pte_t actual_PTE = uvpt[PGNUM(addr)];
+bool modificable = (actual_PTE | PTE_W) == actual_PTE;
+
+if (modificable) MODIFICABLE
+else NO MODIFICABLE
+
+3. En duppage, primero se aloca una página a través de sys_page_alloc. Se mapea la página del proceso padre a una página del proceso hijo. Por último, se deshace el mapeo temporal.
+
+4. Agregaria un chequeo, asi en base a eso el hijo puede o no escribir en la pagina dada:
+
+void
+duppage(envid_t dstenv, void* addr, bool escritura)
+{
+	int r;
+
+  int perm = 0;
+  if (escritura) perm = PTE_W;
+
+	// This is NOT what you should do in your fork.
+	if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|perm)) < 0)
+		panic("sys_page_alloc: %e", r);
+	if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|perm)) < 0)
+		panic("sys_page_map: %e", r);
+	memmove(UTEMP, addr, PGSIZE);
+	if ((r = sys_page_unmap(0, UTEMP)) < 0)
+		panic("sys_page_unmap: %e", r);
+}
+
+Asi las llamadas son las mismas, solo varian los permisos.
+
+5. ROUNDDOWN se usa para redondear para abajo dejando la dirección como multiplo de PGSIZE. El parámetro addr que usamos es la dirección actual. Antes de copiar el stack, copiamos todo el resto del address space a través de un for. Cuando termina ese for, addr queda con la última dirección con la que salió del for. Es decir, la dirección del stack. Se usa ROUNDDOWN y no ROUNDUP porque sino podríamos pasarnos del espacio que tiene el stack.
+
+------------
+
+# multicore_init
+
+1. Lo que se copia con memmove es el entry code del proceso en cuestión. Se copia en la dirección virtual obtenida de MPENTRY_PADDR.
+
+2. La variable mpentry_kstack se usa porque aunque estemos usando todos los procesadores que no son de booteo, necesitamos saber qué stack usar desde mpentry.S para determinado CPU.
+Justamente en los comentarios de mpentry.S, nos dicen que es similar a boot.S excepto que no es necesario habilitar A20 y que se usa MPBOOTPHYS para calcular direcciones absolutas. Entonces si tuvieramos que reservar el espacio como lo hace boot.S, no deberíamos usar MPBOOTPHYS. El problema con esto es que mentry.S es cargada por el bootloader sin ningún tratamiento especial mientras que tiene que ser cargado por un CPU bootstrap by bootloader en 0x7000. Entonces hay que delimitar la dirección de carga original.
+
+3. ``(gdb) watch mpentry_kstack
+Hardware watchpoint 1: mpentry_kstack
+(gdb) continue
+Continuing.
+The target architecture is assumed to be i386
+=> 0xf010019b <boot_aps+127>:	mov    %esi,%ecx
+
+Thread 1 hit Hardware watchpoint 1: mpentry_kstack
+
+Old value = (void *) 0x0
+New value = (void *) 0xf024b000 <percpu_kstacks+65536>
+boot_aps () at kern/init.c:109
+109			lapic_startap(c->cpu_id, PADDR(code));
+(gdb) bt
+#0  boot_aps () at kern/init.c:109
+#1  0xf0100229 in i386_init () at kern/init.c:55
+#2  0xf0100047 in relocated () at kern/entry.S:89
+(gdb) info threads
+  Id   Target Id         Frame
+* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:109
+  2    Thread 2 (CPU#1 [halted ]) 0x000fd412 in ?? ()
+  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
+  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
+(gdb) continue
+Continuing.
+=> 0xf010019b <boot_aps+127>:	mov    %esi,%ecx
+
+Thread 1 hit Hardware watchpoint 1: mpentry_kstack
+
+Old value = (void *) 0xf024b000 <percpu_kstacks+65536>
+New value = (void *) 0xf0253000 <percpu_kstacks+98304>
+boot_aps () at kern/init.c:109
+109			lapic_startap(c->cpu_id, PADDR(code));
+(gdb) info threads
+  Id   Target Id         Frame
+* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:109
+  2    Thread 2 (CPU#1 [running]) spin_lock (lk=0xf01213c0 <kernel_lock>) at kern/spinlock.c:71
+  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
+  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
+(gdb) thread 2
+[Switching to thread 2 (Thread 2)]
+#0  spin_lock (lk=0xf01213c0 <kernel_lock>) at kern/spinlock.c:71
+71		while (xchg(&lk->locked, 1) != 0)
+(gdb) bt
+#0  spin_lock (lk=0xf01213c0 <kernel_lock>) at kern/spinlock.c:71
+#1  0xf010006d in lock_kernel () at ./kern/spinlock.h:33
+#2  0xf01002b9 in mp_main () at kern/init.c:134
+#3  0x00007060 in ?? ()
+(gdb) p cpunum()
+$1 = 1
+(gdb) thread 1
+[Switching to thread 1 (Thread 1)]
+#0  boot_aps () at kern/init.c:111
+111			while(c->cpu_status != CPU_STARTED)
+(gdb) p cpunum()
+$2 = 0
+(gdb) continue
+Continuing.
+=> 0xf010019b <boot_aps+127>:	mov    %esi,%ecx
+
+Thread 1 hit Hardware watchpoint 1: mpentry_kstack
+
+Old value = (void *) 0xf0253000 <percpu_kstacks+98304>
+New value = (void *) 0xf025b000 <percpu_kstacks+131072>
+boot_aps () at kern/init.c:109
+109			lapic_startap(c->cpu_id, PADDR(code));``
+
+4.
+	 a. El valor que tiene es 0x7037 y se ejecuta desde la región de memoria de 0x7000.
+	 0x7037:	0x220f	0x0fd8	0xe020	0xc883	0x0f10	0xe022	0x200f	0x0dc0
+	 0x7047:	0x0001	0x8001	0x220f	0x8bc0
+
+
+	 b. No, la ejecución no se detiene al poner un breakpoint en mpentry.S. Esto sucede porque boot_aps copia el entry point del AP a una parte de la memoria que sea direccionable en modo real. En este caso se decide que sea a 0x7000.
+
+5. ``(gdb) b *0x7000 thread 4
+Breakpoint 1 at 0x7000
+(gdb) continue
+Continuing.
+
+Thread 2 received signal SIGTRAP, Trace/breakpoint trap.
+[Switching to Thread 2]
+warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
+of GDB.  Attempting to continue with the default i8086 settings.
+
+The target architecture is assumed to be i8086
+[ 700:   0]    0x7000:	cli    
+0x00000000 in ?? ()
+(gdb) disable 1
+(gdb) si 10
+The target architecture is assumed to be i386
+=> 0x7020:	mov    $0x10,%ax
+0x00007020 in ?? ()
+(gdb) x/10i $eip
+=> 0x7020:	mov    $0x10,%ax
+   0x7024:	mov    %eax,%ds
+   0x7026:	mov    %eax,%es
+   0x7028:	mov    %eax,%ss
+   0x702a:	mov    $0x0,%ax
+   0x702e:	mov    %eax,%fs
+   0x7030:	mov    %eax,%gs
+   0x7032:	mov    $0x120000,%eax
+   0x7037:	mov    %eax,%cr3
+   0x703a:	mov    %cr4,%eax
+(gdb) watch $eax == 0x120000
+Watchpoint 2: $eax == 0x120000
+(gdb) continue
+Continuing.
+=> 0x7037:	mov    %eax,%cr3
+
+Thread 2 hit Watchpoint 2: $eax == 0x120000
+
+Old value = 0
+New value = 1
+0x00007037 in ?? ()
+(gdb)  p $eip
+$1 = (void (*)()) 0x7037
+(gdb)  p mpentry_kstack
+$2 = (void *) 0x0
+(gdb) disas
+No function contains program counter for selected frame.
+(gdb) si
+=> 0x703a:	mov    %cr4,%eax
+0x0000703a in ?? ()
+(gdb)  p mpentry_kstack
+$3 = (void *) 0x0
+(gdb) si
+=> 0x703d:	or     $0x10,%eax
+
+Thread 2 hit Watchpoint 2: $eax == 0x120000
+
+Old value = 1
+New value = 0
+0x0000703d in ?? ()
+(gdb)  p mpentry_kstack
+$4 = (void *) 0x0
+(gdb) si
+=> 0x7040:	mov    %eax,%cr4
+0x00007040 in ?? ()
+(gdb)
+=> 0x7043:	mov    %cr0,%eax
+0x00007043 in ?? ()
+(gdb)
+=> 0x7046:	or     $0x80010001,%eax
+0x00007046 in ?? ()
+(gdb)
+=> 0x704b:	mov    %eax,%cr0
+0x0000704b in ?? ()
+(gdb)
+=> 0x704e:	mov    0xf023ce84,%esp
+0x0000704e in ?? ()
+(gdb)
+=> 0x7054:	mov    $0x0,%ebp
+0x00007054 in ?? ()
+(gdb)  p mpentry_kstack
+$5 = (void *) 0xf024e000 <percpu_kstacks+65536>``
+
+
+-----------
+
+# sys_ipc_try_send
+
+Se podrían usar las condition variables vistas en concurrencia. Por ejemplo, se puede seguir la idea de wait() donde se suspende la ejecución hasta que se cumpla cierta condición. En nuestro caso será que el proceso B pueda recibir un mensaje llamando a ipc_recv.
+
+-----------
+
+# fork
+
+No, no puede hacerse con la función set_pgfault_handler. Esto es porque se lee la variable global _pgfault_handler_. Esta variable vive es una determinada página que para cuando llega el hijo, ya ha sido copiada por el padre. Además, el padre copió esa página copy on write, por lo que escribir en ella generaría una excepción y todavía no tenemos memoria para la pila de excepciones.
+Deberemos hacer uso de las syscalls sys_page_alloc y sys_page_unmap.
diff --git a/Tp3.txt b/Tp3.txt
new file mode 100644
index 0000000..0ff3ef0
--- /dev/null
+++ b/Tp3.txt
@@ -0,0 +1,974 @@
+diff --git a/TP3.md b/TP3.md
+new file mode 100644
+index 0000000..ac06aba
+--- /dev/null
++++ b/TP3.md
+@@ -0,0 +1,40 @@
++#static_assert
++
++El static_assert de JOS, hace los chequeos en tiempo de compilacion. De esta forma,
++se lanzara un error de compilacion si la condicion x no se cumple. La forma en que hace esto es
++usando un switch. Si el assert da false, nuestro switch estara compuesto por dos cases iguales
++generando un error de compilacion.
++
++--------
++
++#env_return
++
++-  
++
++- La diferencia mas obvia es que en este TP estamos contemplando el uso de muchos CPUs, lo que nos
++permite correr varios procesos en distintos cores. Para el caso de la funcion env_destroy, esto significa
++que cuando llamemmos a esta funcion, ya no estaremos destruyendo el unico proceso en ejecucion. Si el proceso que recibimos es el que se esta ejecutando se corre un nuevo proceso. Por otro lado, si el proceso que recibimos esta corriendo en otro CPU, generaremos un proceso zombie a traves del estado ENV_DYING que sera liberado la proxima vez que se tope con el kernel.
++
++------------
++
++#envid2env
++
++- Como al pasarle 0 a envid2env recibimos el current enviroment, sys_env_destroy lo va a destruir.
++
++- Se envia la senial 9 a cada proceso en el grupo de procesos de llamada.
++
++- Tendremos un error porque ENVX no permite parametros negativos.
++
++- Se envia la senial 9 a todos los procesos que el proceso que llama tenga permisos para enviar seniales.
++
++------------
++
++# dumbfork
++
++------------
++
++#multicore_init
++
++-----------
++
++#sys_ipc_try_send
+diff --git a/grade-lab4 b/grade-lab4
+index 91e52b4..9f0ecd3 100755
+--- a/grade-lab4
++++ b/grade-lab4
+@@ -40,7 +40,7 @@ def test_yield():
+ 
+ @test(1)
+ def test_spin0():
+-    r.user_test("spin0", timeout=0.5)
++    r.user_test("spin0", timeout=3)
+     r.match(E(".00000000. new env $E1"),
+             E(".00000000. new env $E2"),
+             E("I am $E1 and my spin will go on #1"),
+diff --git a/kern/env.c b/kern/env.c
+index 9da921b..a88bee0 100644
+--- a/kern/env.c
++++ b/kern/env.c
+@@ -257,7 +257,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
+ 
+ 	// Enable interrupts while in user mode.
+ 	// LAB 4: Your code here.
+-
++	e->env_tf.tf_eflags = FL_IF;
+ 	// Clear the page fault handler until user installs one.
+ 	e->env_pgfault_upcall = 0;
+ 
+@@ -541,12 +541,13 @@ env_run(struct Env *e)
+ 
+ 	// LAB 3: Your code here.
+ 	// Sigo los pasos recomendados arriba.
+-	if (curenv && e->env_status == ENV_RUNNING)
+-		e->env_status = ENV_RUNNABLE;
++	if (curenv && curenv->env_status == ENV_RUNNING)
++		curenv->env_status = ENV_RUNNABLE;
+ 	curenv = e;
+ 	e->env_status = ENV_RUNNING;
+ 	e->env_runs++;
+ 	lcr3(PADDR(e->env_pgdir));
++	unlock_kernel();	// Desbloqueo el kernel si me dirijo a modo usuario
+ 	env_pop_tf(&e->env_tf);  // Segun entendi env_pop_tf se ocupa de resetear todo el ambiente del proceso.
+ 
+ 	// panic("env_run not yet implemented");
+diff --git a/kern/init.c b/kern/init.c
+index 3c83f7d..bef9291 100644
+--- a/kern/init.c
++++ b/kern/init.c
+@@ -50,7 +50,7 @@ i386_init(void)
+ 
+ 	// Acquire the big kernel lock before waking up APs
+ 	// Your code here:
+-
++	lock_kernel();
+ 	// Starting non-boot CPUs
+ 	boot_aps();
+ 
+@@ -75,7 +75,7 @@ i386_init(void)
+ 
+ 	// Eliminar esta llamada una vez completada la parte 1
+ 	// e implementado sched_yield().
+-	env_run(&envs[0]);
++	//env_run(&envs[0]);
+ 
+ 	// Schedule and run the first user environment!
+ 	sched_yield();
+@@ -103,7 +103,7 @@ boot_aps(void)
+ 		if (c == cpus + cpunum())  // We've started already.
+ 			continue;
+ 
+-		// Tell mpentry.S what stack to use 
++		// Tell mpentry.S what stack to use
+ 		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
+ 		// Start the CPU at mpentry_start
+ 		lapic_startap(c->cpu_id, PADDR(code));
+@@ -117,7 +117,7 @@ boot_aps(void)
+ void
+ mp_main(void)
+ {
+-	// We are in high EIP now, safe to switch to kern_pgdir 
++	// We are in high EIP now, safe to switch to kern_pgdir
+ 	lcr3(PADDR(kern_pgdir));
+ 	cprintf("SMP: CPU %d starting\n", cpunum());
+ 
+@@ -131,9 +131,9 @@ mp_main(void)
+ 	// only one CPU can enter the scheduler at a time!
+ 	//
+ 	// Your code here:
++	lock_kernel();
++	sched_yield();
+ 
+-	// Remove this after you finish Exercise 4
+-	for (;;);
+ }
+ 
+ /*
+diff --git a/kern/mpentry.S b/kern/mpentry.S
+index 72dd827..6db9202 100644
+--- a/kern/mpentry.S
++++ b/kern/mpentry.S
+@@ -33,10 +33,10 @@
+ .set PROT_MODE_CSEG, 0x8	# kernel code segment selector
+ .set PROT_MODE_DSEG, 0x10	# kernel data segment selector
+ 
+-.code16           
++.code16
+ .globl mpentry_start
+ mpentry_start:
+-	cli            
++	cli
+ 
+ 	xorw    %ax, %ax
+ 	movw    %ax, %ds
+@@ -64,6 +64,11 @@ start32:
+ 	# we are still running at a low EIP.
+ 	movl    $(RELOC(entry_pgdir)), %eax
+ 	movl    %eax, %cr3
++
++	movl 	%cr4, %eax
++	orl	$(CR4_PSE), %eax
++	movl	%eax, %cr4
++
+ 	# Turn on paging.
+ 	movl    %cr0, %eax
+ 	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+diff --git a/kern/pmap.c b/kern/pmap.c
+index 3350bb7..5896bde 100644
+--- a/kern/pmap.c
++++ b/kern/pmap.c
+@@ -238,6 +238,8 @@ mem_init(void)
+ 	// we just set up the mapping anyway.
+ 	// Permissions: kernel RW, user NONE
+ 	// Your code goes here:
++	size = ROUNDDOWN((2 ^ 32) - KERNBASE, PGSIZE);
++boot_map_region(kern_pgdir, KERNBASE, size, (physaddr_t) 0, PTE_W | PTE_P);
+ 
+ 	// Initialize the SMP-related parts of the memory map
+ 	mem_init_mp();
+@@ -289,6 +291,16 @@ mem_init_mp(void)
+ 	//     Permissions: kernel RW, user NONE
+ 	//
+ 	// LAB 4: Your code here:
++	uintptr_t start = KSTACKTOP - KSTKSIZE;
++	for(int i = 0; i < NCPU; i++)
++	{
++		boot_map_region(kern_pgdir,
++	            start - i * (KSTKSIZE + KSTKGAP),
++	            KSTKSIZE,
++	            PADDR(&percpu_kstacks[i]),
++	            PTE_W | PTE_P);
++	}
++
+ }
+ 
+ // --------------------------------------------------------------
+@@ -335,14 +347,18 @@ page_init(void)
+ 
+ 	for (i = 0; i < npages; i++) {
+ 		pp_address = page2pa(&pages[i]);
++		ka = page2kva(&pages[i]);
+ 
+-		if (!((i == 0) | ((pp_address >= IOPHYSMEM) &
+-		                  (pp_address < PADDR(boot_alloc(0)))))) {
++		if (i == 0 || (IOPHYSMEM <= pp_address && ka < boot_alloc(0))
++				|| (MPENTRY_PADDR <= pp_address && pp_address < MPENTRY_PADDR + PGSIZE))
++		{
++			pages[i].pp_link = NULL;
++		}
++		else
++		{
+ 			pages[i].pp_ref = 0;
+ 			pages[i].pp_link = page_free_list;
+ 			page_free_list = &pages[i];
+-		} else {
+-			pages[i].pp_link = NULL;
+ 		}
+ 	}
+ }
+@@ -541,7 +557,12 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
+ 	pte_t *pte = pgdir_walk(pgdir, va, 0);
+ 	if (!pte)
+ 		return NULL;
++	if (pte_store)
++		*pte_store = pte;
+ 	physaddr_t pa = PTE_ADDR(*pte);
++
++	if (pte_store != 0) *pte_store = pte;
++
+ 	return pa2page(pa);
+ }
+ 
+@@ -617,7 +638,11 @@ mmio_map_region(physaddr_t pa, size_t size)
+ 	// Hint: The staff solution uses boot_map_region.
+ 	//
+ 	// Your code here:
+-	panic("mmio_map_region not implemented");
++	size = ROUNDUP(size, PGSIZE);
++	uintptr_t auxiliar = base;
++	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
++	base = base + size;
++	return (void*) auxiliar;
+ }
+ 
+ static uintptr_t user_mem_check_addr;
+diff --git a/kern/sched.c b/kern/sched.c
+index 7726e32..be2f896 100644
+--- a/kern/sched.c
++++ b/kern/sched.c
+@@ -29,6 +29,21 @@ sched_yield(void)
+ 	// below to halt the cpu.
+ 
+ 	// LAB 4: Your code here.
++	int start = 0;
++	int j;
++
++	if (curenv) start = ENVX(curenv->env_id) + 1; //Esto nos devuelve el offset en el array envs.
++	//Le sumo 1 para empezar con el que sigue al actual.
++
++	for (int i = 0; i < NENV; i++)
++	{
++		j = (start + i) % NENV; //Recorro desde ese punto.
++		//Usando remainder (%) logro recorrer circularmente.
++		if (envs[j].env_status == ENV_RUNNABLE) env_run(&envs[j]);
++	}
++
++	//Si llegue aca no habia ninguno para correr. Pruebo con el que tenia antes.
++	if (curenv && curenv->env_status == ENV_RUNNING) env_run(curenv);
+ 
+ 	// sched_halt never returns
+ 	sched_halt();
+diff --git a/kern/syscall.c b/kern/syscall.c
+index ab90901..c6ec234 100644
+--- a/kern/syscall.c
++++ b/kern/syscall.c
+@@ -85,7 +85,19 @@ sys_exofork(void)
+ 	// will appear to return 0.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_exofork not implemented");
++
++	struct Env *env;
++	int err = env_alloc(&env, curenv->env_id);
++	if (err < 0)
++		return err;
++
++	env->env_status = ENV_NOT_RUNNABLE;
++	env->env_tf = curenv->env_tf;	//Registros copiados
++	env->env_tf.tf_regs.reg_eax = 0;	//Aparenta devolver 0
++
++	return env->env_id;
++
++	//panic("sys_exofork not implemented");
+ }
+ 
+ // Set envid's env_status to status, which must be ENV_RUNNABLE
+@@ -105,7 +117,16 @@ sys_env_set_status(envid_t envid, int status)
+ 	// envid's status.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_env_set_status not implemented");
++	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE) return -E_INVAL;
++
++	struct Env* env;
++	if (envid2env(envid, &env, 1) < 0) return -E_BAD_ENV;
++
++	env->env_status = status;
++	return 0;
++
++
++	//panic("sys_env_set_status not implemented");
+ }
+ 
+ // Set the page fault upcall for 'envid' by modifying the corresponding struct
+@@ -120,7 +141,16 @@ static int
+ sys_env_set_pgfault_upcall(envid_t envid, void *func)
+ {
+ 	// LAB 4: Your code here.
+-	panic("sys_env_set_pgfault_upcall not implemented");
++
++	struct Env *env;
++	int err = envid2env(envid, &env, 1);
++	if (err < 0) {
++		return -E_BAD_ENV;
++	}
++	env->env_pgfault_upcall = func;
++	return 0;
++
++	//panic("sys_env_set_pgfault_upcall not implemented");
+ }
+ 
+ // Allocate a page of memory and map it at 'va' with permission
+@@ -150,7 +180,29 @@ sys_page_alloc(envid_t envid, void *va, int perm)
+ 	//   allocated!
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_alloc not implemented");
++
++	struct Env* env;
++	struct PageInfo* page;
++	if (envid2env(envid, &env, 1) < 0) return -E_BAD_ENV;
++
++	if (va >= (void*) UTOP || PGOFF(va) != 0)
++		return -E_INVAL;
++
++	if ((perm & ~PTE_SYSCALL) != 0)
++		return -E_INVAL;
++
++	page = page_alloc(ALLOC_ZERO);
++	if (page == NULL)
++		return -E_NO_MEM;
++
++	if (page_insert(env->env_pgdir, page, va, perm | PTE_U | PTE_P) < 0) {
++		page_free(page);
++		return -E_NO_MEM;
++	}
++
++	return 0;
++
++	//panic("sys_page_alloc not implemented");
+ }
+ 
+ // Map the page of memory at 'srcva' in srcenvid's address space
+@@ -180,7 +232,31 @@ sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int p
+ 	//   check the current permissions on the page.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_map not implemented");
++
++	struct Env *srcenv, *dstenv;
++	struct PageInfo *page;
++
++	if (envid2env(srcenvid, &srcenv, 1) < 0) return -E_BAD_ENV;
++	if (envid2env(dstenvid, &dstenv, 1) < 0) return -E_BAD_ENV;
++
++	if (srcva >= (void *) UTOP || PGOFF(srcva) != 0 || dstva >= (void *) UTOP || PGOFF(dstva) != 0)
++		return -E_INVAL;
++
++	//TODO: falta el chequeo de no dar permiso de escritura a una pagina de solo lectura
++	if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) || (perm & ~PTE_SYSCALL) != 0)
++		return -E_INVAL;
++
++	pte_t* pte;
++	page = page_lookup(srcenv->env_pgdir, srcva, &pte);
++	if (page == NULL)
++		return -E_INVAL;
++
++	if (((*pte&PTE_W) == 0) && (perm&PTE_W)) return -E_INVAL;
++
++	if (page_insert(dstenv->env_pgdir, page, dstva, perm) < 0)
++		return -E_NO_MEM;
++
++	return 0;
+ }
+ 
+ // Unmap the page of memory at 'va' in the address space of 'envid'.
+@@ -196,7 +272,19 @@ sys_page_unmap(envid_t envid, void *va)
+ 	// Hint: This function is a wrapper around page_remove().
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_unmap not implemented");
++
++	struct Env* env;
++
++	if (envid2env(envid, &env, 1) < 0) return -E_BAD_ENV;
++
++	if (va >= (void *) UTOP || PGOFF(va) != 0)
++		return -E_INVAL;
++
++	page_remove(env->env_pgdir, va);
++
++	return 0;
++
++	//panic("sys_page_unmap not implemented");
+ }
+ 
+ // Try to send 'value' to the target env 'envid'.
+@@ -241,7 +329,43 @@ static int
+ sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
+ {
+ 	// LAB 4: Your code here.
+-	panic("sys_ipc_try_send not implemented");
++	int err = 0;
++	uintptr_t va = (uintptr_t)srcva;
++	struct Env *env = NULL;
++	if ((err = envid2env(envid, &env, 0)) < 0) {
++		return err;
++	} else if (!env->env_ipc_recving) {
++		return -E_IPC_NOT_RECV;
++	} else if (va < UTOP && (va % PGSIZE) != 0) {
++		return -E_INVAL;
++	} else if (va < UTOP && (perm & ~PTE_SYSCALL) != 0) {
++		return -E_INVAL;
++	}
++
++	int received_perm = 0;
++	if (va < UTOP) {
++		pte_t *pte = NULL;
++		struct PageInfo *page = page_lookup(curenv->env_pgdir, srcva, &pte);
++		if (!page) {
++			return -E_INVAL;
++		} else if ((perm & PTE_W) && !(*pte & PTE_W)) {
++			return -E_INVAL;
++		}
++		if ((err = page_insert(env->env_pgdir, page, env->env_ipc_dstva, perm)) < 0) {
++			return err;
++		}
++		received_perm = perm;
++	}
++
++	env->env_ipc_value = value;
++	env->env_ipc_from = curenv->env_id;
++	env->env_ipc_perm = received_perm;
++
++	env->env_ipc_recving = false;
++	env->env_status = ENV_RUNNABLE;
++	return 0;
++
++	//panic("sys_ipc_try_send not implemented");
+ }
+ 
+ // Block until a value is ready.  Record that you want to receive
+@@ -259,8 +383,22 @@ static int
+ sys_ipc_recv(void *dstva)
+ {
+ 	// LAB 4: Your code here.
+-	panic("sys_ipc_recv not implemented");
+-	return 0;
++
++	if ((uintptr_t)dstva % PGSIZE != 0) {
++		return -E_INVAL;
++	}
++
++	curenv->env_status = ENV_NOT_RUNNABLE;
++	curenv->env_ipc_recving = true;
++
++	if ((uintptr_t)dstva >= UTOP) {
++		curenv->env_tf.tf_regs.reg_eax = 0;
++		sched_yield();
++	}
++
++	curenv->env_ipc_dstva = dstva;
++	curenv->env_tf.tf_regs.reg_eax = 0;
++	sched_yield();
+ }
+ 
+ // Dispatches to the correct kernel function, passing the arguments.
+@@ -286,6 +424,33 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
+ 	case SYS_getenvid:
+ 		return sys_getenvid();
+ 
++		case SYS_yield:
++			sys_yield();
++
++	case SYS_exofork:
++		return sys_exofork();
++
++	case SYS_env_set_status:
++		return sys_env_set_status(a1, a2);
++
++	case SYS_page_alloc:
++		return sys_page_alloc(a1, (void *)a2, a3);
++
++	case SYS_page_map:
++		return sys_page_map(a1, (void *)a2, a3, (void *)a4, a5);
++
++	case SYS_page_unmap:
++		return sys_page_unmap(a1, (void *)a2);
++
++	case SYS_ipc_try_send:
++		return sys_ipc_try_send(a1, a2, (void*)a3, a4);
++
++	case SYS_ipc_recv:
++		return sys_ipc_recv((void*)a1);
++
++	case SYS_env_set_pgfault_upcall:
++		return sys_env_set_pgfault_upcall(a1, (void*)a2);
++
+ 	default:
+ 		return -E_INVAL;
+ 	}
+diff --git a/kern/trap.c b/kern/trap.c
+index ca181b8..8fb2b3f 100644
+--- a/kern/trap.c
++++ b/kern/trap.c
+@@ -14,7 +14,7 @@
+ #include <kern/cpu.h>
+ #include <kern/spinlock.h>
+ 
+-static struct Taskstate ts;
++//static struct Taskstate ts;
+ 
+ /* For debugging, so print_trapframe can distinguish between printing
+  * a saved trapframe and printing the current trapframe and print some
+@@ -91,6 +91,8 @@ trap_init(void)
+ 	void handler18(void);
+ 	void handler19(void);
+ 
++	void handler32(void);
++
+ 	void handler48(void);
+ 
+ 	SETGATE(idt[0], 0, GD_KT, handler0, 0);
+@@ -114,6 +116,8 @@ trap_init(void)
+ 	SETGATE(idt[18], 0, GD_KT, handler18, 0);
+ 	SETGATE(idt[19], 0, GD_KT, handler19, 0);
+ 
++	SETGATE(idt[32], 0, GD_KT, handler32, 0);
++
+ 	SETGATE(idt[48], 0, GD_KT, handler48, 3);
+ 
+ 	// Se podia usar el for, pero no sabia bien como definir el arreglo en
+@@ -154,23 +158,46 @@ trap_init_percpu(void)
+ 	//
+ 	// LAB 4: Your code here:
+ 
++	int cid = thiscpu->cpu_id;
++
+ 	// Setup a TSS so that we get the right stack
+ 	// when we trap to the kernel.
+-	ts.ts_esp0 = KSTACKTOP;
+-	ts.ts_ss0 = GD_KD;
+-	ts.ts_iomb = sizeof(struct Taskstate);
++	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cid * (KSTKSIZE + KSTKGAP);
++	thiscpu->cpu_ts.ts_ss0 = GD_KD;
++	thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);
+ 
+ 	// Initialize the TSS slot of the gdt.
+-	gdt[GD_TSS0 >> 3] =
+-	        SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
+-	gdt[GD_TSS0 >> 3].sd_s = 0;
++	gdt[(GD_TSS0 >> 3)+cid] = SEG16(STS_T32A, (uint32_t) (&(thiscpu->cpu_ts)),
++					sizeof(struct Taskstate) - 1, 0);
++	gdt[(GD_TSS0 >> 3)+cid].sd_s = 0;
+ 
+ 	// Load the TSS selector (like other segment selectors, the
+ 	// bottom three bits are special; we leave them 0)
+-	ltr(GD_TSS0);
++	ltr(GD_TSS0 + (cid << 3));
+ 
+ 	// Load the IDT
+ 	lidt(&idt_pd);
++
++	//Puede estar mal todo lo de arriba. Aca esta lo viejo
++	// // LAB 4: Your code here:
++	//
++	// // Setup a TSS so that we get the right stack
++	// // when we trap to the kernel.
++	// ts.ts_esp0 = KSTACKTOP;
++	// ts.ts_ss0 = GD_KD;
++	// ts.ts_iomb = sizeof(struct Taskstate);
++	//
++	// // Initialize the TSS slot of the gdt.
++	// gdt[GD_TSS0 >> 3] =
++	//         SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
++	// gdt[GD_TSS0 >> 3].sd_s = 0;
++	//
++	// // Load the TSS selector (like other segment selectors, the
++	// // bottom three bits are special; we leave them 0)
++	// ltr(GD_TSS0);
++	//
++	// // Load the IDT
++	// lidt(&idt_pd);
+ }
+ 
+ void
+@@ -225,6 +252,24 @@ trap_dispatch(struct Trapframe *tf)
+ 	// Handle processor exceptions.
+ 	// LAB 3: Your code here.
+ 
++	if (tf->tf_trapno == T_PGFLT) {
++		page_fault_handler(tf);
++		return;
++	}
++ 	if (tf->tf_trapno == T_BRKPT) {
++		monitor(tf);
++		return;
++	}
++ 	if (tf->tf_trapno == T_SYSCALL) {
++		tf->tf_regs.reg_eax = syscall(tf->tf_regs.reg_eax,
++		                              tf->tf_regs.reg_edx,
++		                              tf->tf_regs.reg_ecx,
++		                              tf->tf_regs.reg_ebx,
++		                              tf->tf_regs.reg_edi,
++		                              tf->tf_regs.reg_esi);
++																	return;
++	}
++
+ 	// Handle spurious interrupts
+ 	// The hardware sometimes raises these because of noise on the
+ 	// IRQ line or other reasons. We don't care.
+@@ -237,6 +282,10 @@ trap_dispatch(struct Trapframe *tf)
+ 	// Handle clock interrupts. Don't forget to acknowledge the
+ 	// interrupt using lapic_eoi() before calling the scheduler!
+ 	// LAB 4: Your code here.
++	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
++		lapic_eoi();
++		sched_yield();
++	}
+ 
+ 	// Unexpected trap: The user process or the kernel has a bug.
+ 	print_trapframe(tf);
+@@ -274,6 +323,7 @@ trap(struct Trapframe *tf)
+ 		// Acquire the big kernel lock before doing any
+ 		// serious kernel work.
+ 		// LAB 4: Your code here.
++		lock_kernel();
+ 		assert(curenv);
+ 
+ 		// Garbage collect if current enviroment is a zombie
+@@ -355,11 +405,40 @@ page_fault_handler(struct Trapframe *tf)
+ 
+ 	// LAB 4: Your code here.
+ 
+-	// Destroy the environment that caused the fault.
+-	cprintf("[%08x] user fault va %08x ip %08x\n",
+-	        curenv->env_id,
+-	        fault_va,
+-	        tf->tf_eip);
+-	print_trapframe(tf);
+-	env_destroy(curenv);
++	if (!curenv->env_pgfault_upcall) {
++		// Destroy the environment that caused the fault.
++		cprintf("[%08x] user fault va %08x ip %08x\n",
++		        curenv->env_id,
++		        fault_va,
++		        tf->tf_eip);
++		print_trapframe(tf);
++		env_destroy(curenv);
++		return; //nose si es necesario
++	}
++
++	uintptr_t UXSTACKBOTTOM = UXSTACKTOP - PGSIZE;
++
++	uintptr_t tftop = UXSTACKTOP;
++	if (tf->tf_esp >= UXSTACKBOTTOM && tf->tf_esp < UXSTACKTOP) {
++		// necesita 1 word (4 bytes) en el tope de su stack
++		tftop = tf->tf_esp - 4;
++	}
++
++	struct UTrapframe *utf = (struct UTrapframe *)(tftop - sizeof(struct UTrapframe));
++
++	// el usuario esta autorizado a accedr a la memoria antes de escribir
++	user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
++
++	utf->utf_fault_va = fault_va;
++	utf->utf_err = tf->tf_err;
++	utf->utf_regs = tf->tf_regs;
++	utf->utf_eip = tf->tf_eip;
++	utf->utf_eflags = tf->tf_eflags;
++	utf->utf_esp = tf->tf_esp;
++
++	curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;
++	curenv->env_tf.tf_esp = (uintptr_t)utf;
++
++	env_run(curenv);
++
+ }
+diff --git a/kern/trapentry.S b/kern/trapentry.S
+index 828d412..ea3f5c7 100644
+--- a/kern/trapentry.S
++++ b/kern/trapentry.S
+@@ -75,6 +75,8 @@ manual de Intel. Ademas uso la info que hay en inc/trap.h
+ 	TRAPHANDLER_NOEC(handler18, 18)
+ 	TRAPHANDLER_NOEC(handler19, 19)
+ 
++	TRAPHANDLER_NOEC(handler32, 32)
++
+ 	TRAPHANDLER_NOEC(handler48, 48)
+ 
+ 
+diff --git a/lib/fork.c b/lib/fork.c
+index d32749e..c7654ad 100644
+--- a/lib/fork.c
++++ b/lib/fork.c
+@@ -58,6 +58,65 @@ duppage(envid_t envid, unsigned pn)
+ 	return 0;
+ }
+ 
++static void
++dup_or_share(envid_t dstenv, void *addr, int perm)
++{
++	int r;
++
++	bool escritura = perm == ( perm | PTE_W);
++	if (!escritura) sys_page_map(0, addr, dstenv, addr, perm); //SE DUPLICA
++	else {
++		// This is NOT what you should do in your fork.
++		if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) < 0)
++			panic("sys_page_alloc: %e", r);
++		if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
++			panic("sys_page_map: %e", r);
++		memmove(UTEMP, addr, PGSIZE);
++		if ((r = sys_page_unmap(0, UTEMP)) < 0)
++			panic("sys_page_unmap: %e", r);
++	}
++}
++
++
++envid_t
++fork_v0(void)
++{
++	uint8_t *addr;
++	int r;
++
++	envid_t id = sys_exofork();
++
++	if (id < 0) panic("sys_exofork failed");
++
++	if (id == 0)
++	{	//SOY EL HIJO
++		thisenv = &envs[ENVX(sys_getenvid())];
++		return 0;
++	}
++
++	//Hasta aca igual a dumbfork
++
++	for (addr = 0; addr < (uint8_t*)UTOP; addr += PGSIZE)
++	{
++			//Deberiamos chequear si esta mapeada ?
++			//TODO: Falta conseguir los permisos para el tercer parametro.
++			pde_t actual_PDE = uvpd[PDX(addr)];
++			if ((actual_PDE | PTE_P) != actual_PDE) continue;
++			pte_t actual_PTE = uvpt[PGNUM(addr)];
++			bool mapeada = (actual_PTE | PTE_P) == actual_PTE;
++
++			if (mapeada) dup_or_share(id, addr, actual_PTE & PTE_SYSCALL);
++	}
++
++	//Aca volvemos a copiar a dumbfork
++	// Start the child environment running
++	if ((r = sys_env_set_status(id, ENV_RUNNABLE)) < 0)
++		panic("sys_env_set_status: %e", r);
++
++	return id;
++
++}
++
+ //
+ // User-level fork with copy-on-write.
+ // Set up our page fault handler appropriately.
+@@ -78,9 +137,12 @@ envid_t
+ fork(void)
+ {
+ 	// LAB 4: Your code here.
++	return fork_v0();
+ 	panic("fork not implemented");
+ }
+ 
++
++
+ // Challenge!
+ int
+ sfork(void)
+diff --git a/lib/ipc.c b/lib/ipc.c
+index 2e222b9..7a54908 100644
+--- a/lib/ipc.c
++++ b/lib/ipc.c
+@@ -23,8 +23,19 @@ int32_t
+ ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
+ {
+ 	// LAB 4: Your code here.
+-	panic("ipc_recv not implemented");
+-	return 0;
++
++	int err = sys_ipc_recv(pg ? pg : (void*) KERNBASE);
++	if (err < 0) {	//HUBO ERROR
++		if (from_env_store) *from_env_store = 0;
++		if (perm_store) *perm_store = 0;
++		return err;
++	}
++
++	if (from_env_store) *from_env_store = thisenv->env_ipc_from;
++	if (perm_store) *perm_store = thisenv->env_ipc_perm;
++	return thisenv->env_ipc_value;
++
++	//panic("ipc_recv not implemented");
+ }
+ 
+ // Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
+@@ -39,7 +50,17 @@ void
+ ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
+ {
+ 	// LAB 4: Your code here.
+-	panic("ipc_send not implemented");
++
++	if (!pg) pg = (void*)KERNBASE;
++	int err;
++	while (true) {
++		err = sys_ipc_try_send(to_env, val, pg, perm);
++		if (err == -E_IPC_NOT_RECV) sys_yield();
++		else if (err == 0) break;
++		else panic("ipc_send failed: %e", err);
++		}
++
++	//panic("ipc_send not implemented");
+ }
+ 
+ // Find the first environment of the given type.  We'll use this to
+diff --git a/lib/pfentry.S b/lib/pfentry.S
+index f40aeeb..a58502c 100644
+--- a/lib/pfentry.S
++++ b/lib/pfentry.S
+@@ -37,7 +37,7 @@ _pgfault_upcall:
+ 	movl _pgfault_handler, %eax
+ 	call *%eax
+ 	addl $4, %esp			// pop function argument
+-	
++
+ 	// Now the C page fault handler has returned and you must return
+ 	// to the trap time state.
+ 	// Push trap-time %eip onto the trap-time stack.
+@@ -66,17 +66,33 @@ _pgfault_upcall:
+ 	//
+ 	// LAB 4: Your code here.
+ 
++	movl 40(%esp), %eax
++	movl 48(%esp), %ebx
++	subl $4, %ebx
++	movl %ebx, 48(%esp)
++	mov %eax, (%ebx)
++	addl $8, %esp
++
+ 	// Restore the trap-time registers.  After you do this, you
+ 	// can no longer modify any general-purpose registers.
+ 	// LAB 4: Your code here.
+ 
++	popal
++
+ 	// Restore eflags from the stack.  After you do this, you can
+ 	// no longer use arithmetic operations or anything else that
+ 	// modifies eflags.
+ 	// LAB 4: Your code here.
+ 
++	addl $4, %esp 
++	popfl
++
+ 	// Switch back to the adjusted trap-time stack.
+ 	// LAB 4: Your code here.
+ 
++	popl %esp
++
+ 	// Return to re-execute the instruction that faulted.
+ 	// LAB 4: Your code here.
++
++	ret
+diff --git a/lib/pgfault.c b/lib/pgfault.c
+index a975518..a13aced 100644
+--- a/lib/pgfault.c
++++ b/lib/pgfault.c
+@@ -29,7 +29,12 @@ set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
+ 	if (_pgfault_handler == 0) {
+ 		// First time through!
+ 		// LAB 4: Your code here.
+-		panic("set_pgfault_handler not implemented");
++		int err = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U);
++		if (err < 0) {
++			panic("sys_page_alloc: %e", err);
++		}
++		sys_env_set_pgfault_upcall(0, _pgfault_upcall);
++		//panic("set_pgfault_handler not implemented");
+ 	}
+ 
+ 	// Save handler pointer for assembly to call.
+diff --git a/user/yield.c b/user/yield.c
+index 6f45bdb..99318d9 100644
+--- a/user/yield.c
++++ b/user/yield.c
+@@ -7,11 +7,11 @@ umain(int argc, char **argv)
+ {
+ 	int i;
+ 
+-	cprintf("Hello, I am environment %08x.\n", thisenv->env_id);
++	cprintf("Hello, I am environment %08x, cpu %d.\n", thisenv->env_id, thisenv->env_cpunum);
+ 	for (i = 0; i < 5; i++) {
+ 		sys_yield();
+-		cprintf("Back in environment %08x, iteration %d.\n",
+-			thisenv->env_id, i);
++		cprintf("Back in environment %08x, iteration %d, cpu %d.\n",
++			thisenv->env_id, i, thisenv->env_cpunum);
+ 	}
+-	cprintf("All done in environment %08x.\n", thisenv->env_id);
++	cprintf("All done in environment %08x, cpu %d.\n", thisenv->env_id, thisenv->env_cpunum);
+ }
+
+
+
+helloinit: OK (1.2s) 
+Part 0 score: 1/1
+
+yield: OK (3.4s) 
+spin0: Timeout! OK (6.3s) 
+Part 1 score: 2/2
+
+dumbfork: OK (1.0s) 
+forktree: OK (1.3s) 
+spin: OK (1.1s) 
+Part 2 score: 3/3
+
+yield2: OK (3.9s) 
+stresssched: OK (4.1s) 
+Part 3 score: 2/2
+
+sendpage: OK (1.9s) 
+pingpong: OK (1.7s) 
+primes: OK (7.9s) 
+Part 4 score: 3/3
+
+faultread: OK (2.5s) 
+faultwrite: OK (3.3s) 
+faultdie: OK (2.5s) 
+faultregs: OK (1.0s) 
+faultalloc: OK (1.0s) 
+faultallocbad: FAIL (3.4s) 
+    AssertionError: ...
+         >>> kernel panic on CPU 0 at kern/trap.c:373: Kernel page fault!
+         >>>
+         Welcome to the JOS kernel monitor!
+         Type 'help' for a list of commands.
+         qemu-system-i386: terminating on signal 15 from pid 12417 (make)
+    MISSING '.00001000. user_mem_check assertion failure for va deadbeef'
+    MISSING '.00001000. free env 00001000'
+    
+    QEMU output saved to jos.out.faultallocbad
+faultnostack: OK (3.3s) 
+faultbadhandler: OK (2.9s) 
+faultevilhandler: OK (2.2s) 
+Part 5 score: 8/9
+
+Score: 19/20
+
diff --git a/grade-lab4 b/grade-lab4
index 91e52b4..9f0ecd3 100755
--- a/grade-lab4
+++ b/grade-lab4
@@ -40,7 +40,7 @@ def test_yield():
 
 @test(1)
 def test_spin0():
-    r.user_test("spin0", timeout=0.5)
+    r.user_test("spin0", timeout=3)
     r.match(E(".00000000. new env $E1"),
             E(".00000000. new env $E2"),
             E("I am $E1 and my spin will go on #1"),
diff --git a/kern/env.c b/kern/env.c
index 9da921b..a88bee0 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -257,7 +257,7 @@ env_alloc(struct Env **newenv_store, envid_t parent_id)
 
 	// Enable interrupts while in user mode.
 	// LAB 4: Your code here.
-
+	e->env_tf.tf_eflags = FL_IF;
 	// Clear the page fault handler until user installs one.
 	e->env_pgfault_upcall = 0;
 
@@ -541,12 +541,13 @@ env_run(struct Env *e)
 
 	// LAB 3: Your code here.
 	// Sigo los pasos recomendados arriba.
-	if (curenv && e->env_status == ENV_RUNNING)
-		e->env_status = ENV_RUNNABLE;
+	if (curenv && curenv->env_status == ENV_RUNNING)
+		curenv->env_status = ENV_RUNNABLE;
 	curenv = e;
 	e->env_status = ENV_RUNNING;
 	e->env_runs++;
 	lcr3(PADDR(e->env_pgdir));
+	unlock_kernel();	// Desbloqueo el kernel si me dirijo a modo usuario
 	env_pop_tf(&e->env_tf);  // Segun entendi env_pop_tf se ocupa de resetear todo el ambiente del proceso.
 
 	// panic("env_run not yet implemented");
diff --git a/kern/init.c b/kern/init.c
index 3c83f7d..bef9291 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -50,7 +50,7 @@ i386_init(void)
 
 	// Acquire the big kernel lock before waking up APs
 	// Your code here:
-
+	lock_kernel();
 	// Starting non-boot CPUs
 	boot_aps();
 
@@ -75,7 +75,7 @@ i386_init(void)
 
 	// Eliminar esta llamada una vez completada la parte 1
 	// e implementado sched_yield().
-	env_run(&envs[0]);
+	//env_run(&envs[0]);
 
 	// Schedule and run the first user environment!
 	sched_yield();
@@ -103,7 +103,7 @@ boot_aps(void)
 		if (c == cpus + cpunum())  // We've started already.
 			continue;
 
-		// Tell mpentry.S what stack to use 
+		// Tell mpentry.S what stack to use
 		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
 		// Start the CPU at mpentry_start
 		lapic_startap(c->cpu_id, PADDR(code));
@@ -117,7 +117,7 @@ boot_aps(void)
 void
 mp_main(void)
 {
-	// We are in high EIP now, safe to switch to kern_pgdir 
+	// We are in high EIP now, safe to switch to kern_pgdir
 	lcr3(PADDR(kern_pgdir));
 	cprintf("SMP: CPU %d starting\n", cpunum());
 
@@ -131,9 +131,9 @@ mp_main(void)
 	// only one CPU can enter the scheduler at a time!
 	//
 	// Your code here:
+	lock_kernel();
+	sched_yield();
 
-	// Remove this after you finish Exercise 4
-	for (;;);
 }
 
 /*
diff --git a/kern/mpentry.S b/kern/mpentry.S
index 72dd827..6db9202 100644
--- a/kern/mpentry.S
+++ b/kern/mpentry.S
@@ -33,10 +33,10 @@
 .set PROT_MODE_CSEG, 0x8	# kernel code segment selector
 .set PROT_MODE_DSEG, 0x10	# kernel data segment selector
 
-.code16           
+.code16
 .globl mpentry_start
 mpentry_start:
-	cli            
+	cli
 
 	xorw    %ax, %ax
 	movw    %ax, %ds
@@ -64,6 +64,11 @@ start32:
 	# we are still running at a low EIP.
 	movl    $(RELOC(entry_pgdir)), %eax
 	movl    %eax, %cr3
+
+	movl 	%cr4, %eax
+	orl	$(CR4_PSE), %eax
+	movl	%eax, %cr4
+
 	# Turn on paging.
 	movl    %cr0, %eax
 	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
diff --git a/kern/pmap.c b/kern/pmap.c
index 3350bb7..ec42632 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -238,6 +238,8 @@ mem_init(void)
 	// we just set up the mapping anyway.
 	// Permissions: kernel RW, user NONE
 	// Your code goes here:
+	size = ROUNDDOWN((2 ^ 32) - KERNBASE, PGSIZE);
+boot_map_region(kern_pgdir, KERNBASE, size, (physaddr_t) 0, PTE_W | PTE_P);
 
 	// Initialize the SMP-related parts of the memory map
 	mem_init_mp();
@@ -289,6 +291,16 @@ mem_init_mp(void)
 	//     Permissions: kernel RW, user NONE
 	//
 	// LAB 4: Your code here:
+	uintptr_t start = KSTACKTOP - KSTKSIZE;
+	for(int i = 0; i < NCPU; i++)
+	{
+		boot_map_region(kern_pgdir,
+	            start - i * (KSTKSIZE + KSTKGAP),
+	            KSTKSIZE,
+	            PADDR(&percpu_kstacks[i]),
+	            PTE_W | PTE_P);
+	}
+
 }
 
 // --------------------------------------------------------------
@@ -335,14 +347,18 @@ page_init(void)
 
 	for (i = 0; i < npages; i++) {
 		pp_address = page2pa(&pages[i]);
+		ka = page2kva(&pages[i]);
 
-		if (!((i == 0) | ((pp_address >= IOPHYSMEM) &
-		                  (pp_address < PADDR(boot_alloc(0)))))) {
+		if (i == 0 || (IOPHYSMEM <= pp_address && ka < boot_alloc(0))
+				|| (MPENTRY_PADDR <= pp_address && pp_address < MPENTRY_PADDR + PGSIZE))
+		{
+			pages[i].pp_link = NULL;
+		}
+		else
+		{
 			pages[i].pp_ref = 0;
 			pages[i].pp_link = page_free_list;
 			page_free_list = &pages[i];
-		} else {
-			pages[i].pp_link = NULL;
 		}
 	}
 }
@@ -541,7 +557,12 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 	pte_t *pte = pgdir_walk(pgdir, va, 0);
 	if (!pte)
 		return NULL;
+	if (pte_store)
+		*pte_store = pte;
 	physaddr_t pa = PTE_ADDR(*pte);
+
+	if (pte_store != 0) *pte_store = pte;
+
 	return pa2page(pa);
 }
 
@@ -617,7 +638,11 @@ mmio_map_region(physaddr_t pa, size_t size)
 	// Hint: The staff solution uses boot_map_region.
 	//
 	// Your code here:
-	panic("mmio_map_region not implemented");
+	size = ROUNDUP(size, PGSIZE);
+	uintptr_t auxiliar = base;
+	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
+	base = base + size;
+	return (void*) auxiliar;
 }
 
 static uintptr_t user_mem_check_addr;
@@ -654,7 +679,7 @@ user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 		                        (void *) i,
 		                        0);  // Obtengo la pte correrspondiente
 
-		if ((i >= ULIM) || ((*pte & perm) !=
+		if ((pte == NULL) || (i >= ULIM) || ((*pte & perm) !=
 		                    perm))  // Condiciones donde no es user program
 		{
 			if (i < (uint32_t) va)
diff --git a/kern/sched.c b/kern/sched.c
index 7726e32..be2f896 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -29,6 +29,21 @@ sched_yield(void)
 	// below to halt the cpu.
 
 	// LAB 4: Your code here.
+	int start = 0;
+	int j;
+
+	if (curenv) start = ENVX(curenv->env_id) + 1; //Esto nos devuelve el offset en el array envs.
+	//Le sumo 1 para empezar con el que sigue al actual.
+
+	for (int i = 0; i < NENV; i++)
+	{
+		j = (start + i) % NENV; //Recorro desde ese punto.
+		//Usando remainder (%) logro recorrer circularmente.
+		if (envs[j].env_status == ENV_RUNNABLE) env_run(&envs[j]);
+	}
+
+	//Si llegue aca no habia ninguno para correr. Pruebo con el que tenia antes.
+	if (curenv && curenv->env_status == ENV_RUNNING) env_run(curenv);
 
 	// sched_halt never returns
 	sched_halt();
diff --git a/kern/syscall.c b/kern/syscall.c
index ab90901..c6ec234 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -85,7 +85,19 @@ sys_exofork(void)
 	// will appear to return 0.
 
 	// LAB 4: Your code here.
-	panic("sys_exofork not implemented");
+
+	struct Env *env;
+	int err = env_alloc(&env, curenv->env_id);
+	if (err < 0)
+		return err;
+
+	env->env_status = ENV_NOT_RUNNABLE;
+	env->env_tf = curenv->env_tf;	//Registros copiados
+	env->env_tf.tf_regs.reg_eax = 0;	//Aparenta devolver 0
+
+	return env->env_id;
+
+	//panic("sys_exofork not implemented");
 }
 
 // Set envid's env_status to status, which must be ENV_RUNNABLE
@@ -105,7 +117,16 @@ sys_env_set_status(envid_t envid, int status)
 	// envid's status.
 
 	// LAB 4: Your code here.
-	panic("sys_env_set_status not implemented");
+	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE) return -E_INVAL;
+
+	struct Env* env;
+	if (envid2env(envid, &env, 1) < 0) return -E_BAD_ENV;
+
+	env->env_status = status;
+	return 0;
+
+
+	//panic("sys_env_set_status not implemented");
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -120,7 +141,16 @@ static int
 sys_env_set_pgfault_upcall(envid_t envid, void *func)
 {
 	// LAB 4: Your code here.
-	panic("sys_env_set_pgfault_upcall not implemented");
+
+	struct Env *env;
+	int err = envid2env(envid, &env, 1);
+	if (err < 0) {
+		return -E_BAD_ENV;
+	}
+	env->env_pgfault_upcall = func;
+	return 0;
+
+	//panic("sys_env_set_pgfault_upcall not implemented");
 }
 
 // Allocate a page of memory and map it at 'va' with permission
@@ -150,7 +180,29 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 	//   allocated!
 
 	// LAB 4: Your code here.
-	panic("sys_page_alloc not implemented");
+
+	struct Env* env;
+	struct PageInfo* page;
+	if (envid2env(envid, &env, 1) < 0) return -E_BAD_ENV;
+
+	if (va >= (void*) UTOP || PGOFF(va) != 0)
+		return -E_INVAL;
+
+	if ((perm & ~PTE_SYSCALL) != 0)
+		return -E_INVAL;
+
+	page = page_alloc(ALLOC_ZERO);
+	if (page == NULL)
+		return -E_NO_MEM;
+
+	if (page_insert(env->env_pgdir, page, va, perm | PTE_U | PTE_P) < 0) {
+		page_free(page);
+		return -E_NO_MEM;
+	}
+
+	return 0;
+
+	//panic("sys_page_alloc not implemented");
 }
 
 // Map the page of memory at 'srcva' in srcenvid's address space
@@ -180,7 +232,31 @@ sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int p
 	//   check the current permissions on the page.
 
 	// LAB 4: Your code here.
-	panic("sys_page_map not implemented");
+
+	struct Env *srcenv, *dstenv;
+	struct PageInfo *page;
+
+	if (envid2env(srcenvid, &srcenv, 1) < 0) return -E_BAD_ENV;
+	if (envid2env(dstenvid, &dstenv, 1) < 0) return -E_BAD_ENV;
+
+	if (srcva >= (void *) UTOP || PGOFF(srcva) != 0 || dstva >= (void *) UTOP || PGOFF(dstva) != 0)
+		return -E_INVAL;
+
+	//TODO: falta el chequeo de no dar permiso de escritura a una pagina de solo lectura
+	if ((perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) || (perm & ~PTE_SYSCALL) != 0)
+		return -E_INVAL;
+
+	pte_t* pte;
+	page = page_lookup(srcenv->env_pgdir, srcva, &pte);
+	if (page == NULL)
+		return -E_INVAL;
+
+	if (((*pte&PTE_W) == 0) && (perm&PTE_W)) return -E_INVAL;
+
+	if (page_insert(dstenv->env_pgdir, page, dstva, perm) < 0)
+		return -E_NO_MEM;
+
+	return 0;
 }
 
 // Unmap the page of memory at 'va' in the address space of 'envid'.
@@ -196,7 +272,19 @@ sys_page_unmap(envid_t envid, void *va)
 	// Hint: This function is a wrapper around page_remove().
 
 	// LAB 4: Your code here.
-	panic("sys_page_unmap not implemented");
+
+	struct Env* env;
+
+	if (envid2env(envid, &env, 1) < 0) return -E_BAD_ENV;
+
+	if (va >= (void *) UTOP || PGOFF(va) != 0)
+		return -E_INVAL;
+
+	page_remove(env->env_pgdir, va);
+
+	return 0;
+
+	//panic("sys_page_unmap not implemented");
 }
 
 // Try to send 'value' to the target env 'envid'.
@@ -241,7 +329,43 @@ static int
 sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 {
 	// LAB 4: Your code here.
-	panic("sys_ipc_try_send not implemented");
+	int err = 0;
+	uintptr_t va = (uintptr_t)srcva;
+	struct Env *env = NULL;
+	if ((err = envid2env(envid, &env, 0)) < 0) {
+		return err;
+	} else if (!env->env_ipc_recving) {
+		return -E_IPC_NOT_RECV;
+	} else if (va < UTOP && (va % PGSIZE) != 0) {
+		return -E_INVAL;
+	} else if (va < UTOP && (perm & ~PTE_SYSCALL) != 0) {
+		return -E_INVAL;
+	}
+
+	int received_perm = 0;
+	if (va < UTOP) {
+		pte_t *pte = NULL;
+		struct PageInfo *page = page_lookup(curenv->env_pgdir, srcva, &pte);
+		if (!page) {
+			return -E_INVAL;
+		} else if ((perm & PTE_W) && !(*pte & PTE_W)) {
+			return -E_INVAL;
+		}
+		if ((err = page_insert(env->env_pgdir, page, env->env_ipc_dstva, perm)) < 0) {
+			return err;
+		}
+		received_perm = perm;
+	}
+
+	env->env_ipc_value = value;
+	env->env_ipc_from = curenv->env_id;
+	env->env_ipc_perm = received_perm;
+
+	env->env_ipc_recving = false;
+	env->env_status = ENV_RUNNABLE;
+	return 0;
+
+	//panic("sys_ipc_try_send not implemented");
 }
 
 // Block until a value is ready.  Record that you want to receive
@@ -259,8 +383,22 @@ static int
 sys_ipc_recv(void *dstva)
 {
 	// LAB 4: Your code here.
-	panic("sys_ipc_recv not implemented");
-	return 0;
+
+	if ((uintptr_t)dstva % PGSIZE != 0) {
+		return -E_INVAL;
+	}
+
+	curenv->env_status = ENV_NOT_RUNNABLE;
+	curenv->env_ipc_recving = true;
+
+	if ((uintptr_t)dstva >= UTOP) {
+		curenv->env_tf.tf_regs.reg_eax = 0;
+		sched_yield();
+	}
+
+	curenv->env_ipc_dstva = dstva;
+	curenv->env_tf.tf_regs.reg_eax = 0;
+	sched_yield();
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
@@ -286,6 +424,33 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 	case SYS_getenvid:
 		return sys_getenvid();
 
+		case SYS_yield:
+			sys_yield();
+
+	case SYS_exofork:
+		return sys_exofork();
+
+	case SYS_env_set_status:
+		return sys_env_set_status(a1, a2);
+
+	case SYS_page_alloc:
+		return sys_page_alloc(a1, (void *)a2, a3);
+
+	case SYS_page_map:
+		return sys_page_map(a1, (void *)a2, a3, (void *)a4, a5);
+
+	case SYS_page_unmap:
+		return sys_page_unmap(a1, (void *)a2);
+
+	case SYS_ipc_try_send:
+		return sys_ipc_try_send(a1, a2, (void*)a3, a4);
+
+	case SYS_ipc_recv:
+		return sys_ipc_recv((void*)a1);
+
+	case SYS_env_set_pgfault_upcall:
+		return sys_env_set_pgfault_upcall(a1, (void*)a2);
+
 	default:
 		return -E_INVAL;
 	}
diff --git a/kern/trap.c b/kern/trap.c
index ca181b8..8fb2b3f 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -14,7 +14,7 @@
 #include <kern/cpu.h>
 #include <kern/spinlock.h>
 
-static struct Taskstate ts;
+//static struct Taskstate ts;
 
 /* For debugging, so print_trapframe can distinguish between printing
  * a saved trapframe and printing the current trapframe and print some
@@ -91,6 +91,8 @@ trap_init(void)
 	void handler18(void);
 	void handler19(void);
 
+	void handler32(void);
+
 	void handler48(void);
 
 	SETGATE(idt[0], 0, GD_KT, handler0, 0);
@@ -114,6 +116,8 @@ trap_init(void)
 	SETGATE(idt[18], 0, GD_KT, handler18, 0);
 	SETGATE(idt[19], 0, GD_KT, handler19, 0);
 
+	SETGATE(idt[32], 0, GD_KT, handler32, 0);
+
 	SETGATE(idt[48], 0, GD_KT, handler48, 3);
 
 	// Se podia usar el for, pero no sabia bien como definir el arreglo en
@@ -154,23 +158,46 @@ trap_init_percpu(void)
 	//
 	// LAB 4: Your code here:
 
+	int cid = thiscpu->cpu_id;
+
 	// Setup a TSS so that we get the right stack
 	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-	ts.ts_iomb = sizeof(struct Taskstate);
+	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cid * (KSTKSIZE + KSTKGAP);
+	thiscpu->cpu_ts.ts_ss0 = GD_KD;
+	thiscpu->cpu_ts.ts_iomb = sizeof(struct Taskstate);
 
 	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] =
-	        SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
+	gdt[(GD_TSS0 >> 3)+cid] = SEG16(STS_T32A, (uint32_t) (&(thiscpu->cpu_ts)),
+					sizeof(struct Taskstate) - 1, 0);
+	gdt[(GD_TSS0 >> 3)+cid].sd_s = 0;
 
 	// Load the TSS selector (like other segment selectors, the
 	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
+	ltr(GD_TSS0 + (cid << 3));
 
 	// Load the IDT
 	lidt(&idt_pd);
+
+	//Puede estar mal todo lo de arriba. Aca esta lo viejo
+	// // LAB 4: Your code here:
+	//
+	// // Setup a TSS so that we get the right stack
+	// // when we trap to the kernel.
+	// ts.ts_esp0 = KSTACKTOP;
+	// ts.ts_ss0 = GD_KD;
+	// ts.ts_iomb = sizeof(struct Taskstate);
+	//
+	// // Initialize the TSS slot of the gdt.
+	// gdt[GD_TSS0 >> 3] =
+	//         SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
+	// gdt[GD_TSS0 >> 3].sd_s = 0;
+	//
+	// // Load the TSS selector (like other segment selectors, the
+	// // bottom three bits are special; we leave them 0)
+	// ltr(GD_TSS0);
+	//
+	// // Load the IDT
+	// lidt(&idt_pd);
 }
 
 void
@@ -225,6 +252,24 @@ trap_dispatch(struct Trapframe *tf)
 	// Handle processor exceptions.
 	// LAB 3: Your code here.
 
+	if (tf->tf_trapno == T_PGFLT) {
+		page_fault_handler(tf);
+		return;
+	}
+ 	if (tf->tf_trapno == T_BRKPT) {
+		monitor(tf);
+		return;
+	}
+ 	if (tf->tf_trapno == T_SYSCALL) {
+		tf->tf_regs.reg_eax = syscall(tf->tf_regs.reg_eax,
+		                              tf->tf_regs.reg_edx,
+		                              tf->tf_regs.reg_ecx,
+		                              tf->tf_regs.reg_ebx,
+		                              tf->tf_regs.reg_edi,
+		                              tf->tf_regs.reg_esi);
+																	return;
+	}
+
 	// Handle spurious interrupts
 	// The hardware sometimes raises these because of noise on the
 	// IRQ line or other reasons. We don't care.
@@ -237,6 +282,10 @@ trap_dispatch(struct Trapframe *tf)
 	// Handle clock interrupts. Don't forget to acknowledge the
 	// interrupt using lapic_eoi() before calling the scheduler!
 	// LAB 4: Your code here.
+	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
+		lapic_eoi();
+		sched_yield();
+	}
 
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
@@ -274,6 +323,7 @@ trap(struct Trapframe *tf)
 		// Acquire the big kernel lock before doing any
 		// serious kernel work.
 		// LAB 4: Your code here.
+		lock_kernel();
 		assert(curenv);
 
 		// Garbage collect if current enviroment is a zombie
@@ -355,11 +405,40 @@ page_fault_handler(struct Trapframe *tf)
 
 	// LAB 4: Your code here.
 
-	// Destroy the environment that caused the fault.
-	cprintf("[%08x] user fault va %08x ip %08x\n",
-	        curenv->env_id,
-	        fault_va,
-	        tf->tf_eip);
-	print_trapframe(tf);
-	env_destroy(curenv);
+	if (!curenv->env_pgfault_upcall) {
+		// Destroy the environment that caused the fault.
+		cprintf("[%08x] user fault va %08x ip %08x\n",
+		        curenv->env_id,
+		        fault_va,
+		        tf->tf_eip);
+		print_trapframe(tf);
+		env_destroy(curenv);
+		return; //nose si es necesario
+	}
+
+	uintptr_t UXSTACKBOTTOM = UXSTACKTOP - PGSIZE;
+
+	uintptr_t tftop = UXSTACKTOP;
+	if (tf->tf_esp >= UXSTACKBOTTOM && tf->tf_esp < UXSTACKTOP) {
+		// necesita 1 word (4 bytes) en el tope de su stack
+		tftop = tf->tf_esp - 4;
+	}
+
+	struct UTrapframe *utf = (struct UTrapframe *)(tftop - sizeof(struct UTrapframe));
+
+	// el usuario esta autorizado a accedr a la memoria antes de escribir
+	user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
+
+	utf->utf_fault_va = fault_va;
+	utf->utf_err = tf->tf_err;
+	utf->utf_regs = tf->tf_regs;
+	utf->utf_eip = tf->tf_eip;
+	utf->utf_eflags = tf->tf_eflags;
+	utf->utf_esp = tf->tf_esp;
+
+	curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;
+	curenv->env_tf.tf_esp = (uintptr_t)utf;
+
+	env_run(curenv);
+
 }
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 828d412..ea3f5c7 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -75,6 +75,8 @@ manual de Intel. Ademas uso la info que hay en inc/trap.h
 	TRAPHANDLER_NOEC(handler18, 18)
 	TRAPHANDLER_NOEC(handler19, 19)
 
+	TRAPHANDLER_NOEC(handler32, 32)
+
 	TRAPHANDLER_NOEC(handler48, 48)
 
 
diff --git a/lib/fork.c b/lib/fork.c
index d32749e..39f1413 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -25,6 +25,8 @@ pgfault(struct UTrapframe *utf)
 	//   (see <inc/memlayout.h>).
 
 	// LAB 4: Your code here.
+	pte_t actual_PTE = uvpt[PGNUM(addr)];
+	if (!(err & FEC_WR) || !(actual_PTE & PTE_COW)) panic("No es COW");
 
 	// Allocate a new page, map it at a temporary location (PFTEMP),
 	// copy the data from the old page to the new page, then move the new
@@ -33,8 +35,16 @@ pgfault(struct UTrapframe *utf)
 	//   You should make three system calls.
 
 	// LAB 4: Your code here.
+	addr = ROUNDDOWN(addr, PGSIZE);
 
-	panic("pgfault not implemented");
+	if (sys_page_alloc(0, PFTEMP, PTE_W|PTE_U|PTE_P) < 0) panic("sys_page_alloc");
+	memcpy(PFTEMP, addr, PGSIZE);
+
+	if (sys_page_map(0, PFTEMP, 0, addr, PTE_W|PTE_U|PTE_P) < 0) panic("sys_page_map");
+
+	if (sys_page_unmap(0, PFTEMP) < 0) panic("sys_page_unmap");
+
+	//panic("pgfault not implemented");
 }
 
 //
@@ -54,10 +64,79 @@ duppage(envid_t envid, unsigned pn)
 	int r;
 
 	// LAB 4: Your code here.
-	panic("duppage not implemented");
+	//Calculo la direccion a partir del numero de pagina.
+	void *addr = (void*) (pn*PGSIZE);
+
+	if ((uvpt[pn] & PTE_W) || (uvpt[pn] & PTE_COW))
+	{
+		if (sys_page_map(0, addr, envid, addr, PTE_COW|PTE_U|PTE_P) < 0)
+			panic("Error 1");
+		if (sys_page_map(0, addr, 0, addr, PTE_COW|PTE_U|PTE_P) < 0)
+			panic("Error 2");
+	}
+	else sys_page_map(0, addr, envid, addr, PTE_U|PTE_P);
+
+	//panic("duppage not implemented");
 	return 0;
 }
 
+static void
+dup_or_share(envid_t dstenv, void *addr, int perm)
+{
+	int r;
+
+	bool escritura = perm == ( perm | PTE_W);
+	if (!escritura) sys_page_map(0, addr, dstenv, addr, perm); //SE DUPLICA
+	else {
+		// This is NOT what you should do in your fork.
+		if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) < 0)
+			panic("sys_page_alloc: %e", r);
+		if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) < 0)
+			panic("sys_page_map: %e", r);
+		memmove(UTEMP, addr, PGSIZE);
+		if ((r = sys_page_unmap(0, UTEMP)) < 0)
+			panic("sys_page_unmap: %e", r);
+	}
+}
+
+
+envid_t
+fork_v0(void)
+{
+	uint8_t *addr;
+	int r;
+
+	envid_t id = sys_exofork();
+
+	if (id < 0) panic("sys_exofork failed");
+
+	if (id == 0)
+	{	//SOY EL HIJO
+		thisenv = &envs[ENVX(sys_getenvid())];
+		return 0;
+	}
+
+	//Hasta aca igual a dumbfork
+
+	for (addr = 0; addr < (uint8_t*)UTOP; addr += PGSIZE)
+	{
+			pde_t actual_PDE = uvpd[PDX(addr)];
+			if ((actual_PDE | PTE_P) != actual_PDE) continue;
+			pte_t actual_PTE = uvpt[PGNUM(addr)];
+			bool mapeada = (actual_PTE | PTE_P) == actual_PTE;
+
+			if (mapeada) dup_or_share(id, addr, actual_PTE & PTE_SYSCALL);
+	}
+
+	//Aca volvemos a copiar a dumbfork
+	// Start the child environment running
+	if ((r = sys_env_set_status(id, ENV_RUNNABLE)) < 0)
+		panic("sys_env_set_status: %e", r);
+
+	return id;
+
+}
+
 //
 // User-level fork with copy-on-write.
 // Set up our page fault handler appropriately.
@@ -78,9 +157,53 @@ envid_t
 fork(void)
 {
 	// LAB 4: Your code here.
-	panic("fork not implemented");
+	//return fork_v0();
+
+	//Instalo el manejador de pagefaults
+	set_pgfault_handler(pgfault);
+
+	uint8_t *addr;
+	int r;
+	//Hacemos como siempre el llamado a sys_exofork
+	envid_t id = sys_exofork();
+
+	if (id < 0) panic("sys_exofork failed");
+
+	if (id == 0)
+	{	//SOY EL HIJO
+		thisenv = &envs[ENVX(sys_getenvid())];
+		return 0;
+	}
+
+	//Reservar memoria para la pila de excepciones del hijo, e instalar su manejador de excepciones.
+	//ESto hay que hacerlo a mano como dijo Dato.
+	if (sys_page_alloc(id, (void *)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P) < 0)
+	panic("Fallo el sys_page_alloc");
+	extern void _pgfault_upcall();
+	sys_env_set_pgfault_upcall(id, _pgfault_upcall);
+
+	for (addr = 0; addr <(uint8_t*)UTOP; addr += PGSIZE)
+	{
+		pde_t actual_PDE = uvpd[PDX(addr)];
+		if ((actual_PDE | PTE_P) != actual_PDE) continue;
+		pte_t actual_PTE = uvpt[PGNUM(addr)];
+		if ((actual_PTE & PTE_P)
+			&& (actual_PTE & PTE_U))
+		{
+			if (PGNUM(addr) >= PGNUM(UXSTACKTOP - PGSIZE) && (PGNUM(addr) < PGNUM(UXSTACKTOP))) continue;
+			duppage(id, PGNUM(addr));
+		}
+	}
+
+	//Seteamos al hijo en ENV_RUNNABLE
+	if ((r = sys_env_set_status(id, ENV_RUNNABLE)) < 0)
+		panic("sys_env_set_status: %e", r);
+
+	return id;
 }
 
+
+
 // Challenge!
 int
 sfork(void)
diff --git a/lib/ipc.c b/lib/ipc.c
index 2e222b9..7a54908 100644
--- a/lib/ipc.c
+++ b/lib/ipc.c
@@ -23,8 +23,19 @@ int32_t
 ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 {
 	// LAB 4: Your code here.
-	panic("ipc_recv not implemented");
-	return 0;
+
+	int err = sys_ipc_recv(pg ? pg : (void*) KERNBASE);
+	if (err < 0) {	//HUBO ERROR
+		if (from_env_store) *from_env_store = 0;
+		if (perm_store) *perm_store = 0;
+		return err;
+	}
+
+	if (from_env_store) *from_env_store = thisenv->env_ipc_from;
+	if (perm_store) *perm_store = thisenv->env_ipc_perm;
+	return thisenv->env_ipc_value;
+
+	//panic("ipc_recv not implemented");
 }
 
 // Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
@@ -39,7 +50,17 @@ void
 ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
 {
 	// LAB 4: Your code here.
-	panic("ipc_send not implemented");
+
+	if (!pg) pg = (void*)KERNBASE;
+	int err;
+	while (true) {
+		err = sys_ipc_try_send(to_env, val, pg, perm);
+		if (err == -E_IPC_NOT_RECV) sys_yield();
+		else if (err == 0) break;
+		else panic("ipc_send failed: %e", err);
+		}
+
+	//panic("ipc_send not implemented");
 }
 
 // Find the first environment of the given type.  We'll use this to
diff --git a/lib/pfentry.S b/lib/pfentry.S
index f40aeeb..a58502c 100644
--- a/lib/pfentry.S
+++ b/lib/pfentry.S
@@ -37,7 +37,7 @@ _pgfault_upcall:
 	movl _pgfault_handler, %eax
 	call *%eax
 	addl $4, %esp			// pop function argument
-	
+
 	// Now the C page fault handler has returned and you must return
 	// to the trap time state.
 	// Push trap-time %eip onto the trap-time stack.
@@ -66,17 +66,33 @@ _pgfault_upcall:
 	//
 	// LAB 4: Your code here.
 
+	movl 40(%esp), %eax
+	movl 48(%esp), %ebx
+	subl $4, %ebx
+	movl %ebx, 48(%esp)
+	mov %eax, (%ebx)
+	addl $8, %esp
+
 	// Restore the trap-time registers.  After you do this, you
 	// can no longer modify any general-purpose registers.
 	// LAB 4: Your code here.
 
+	popal
+
 	// Restore eflags from the stack.  After you do this, you can
 	// no longer use arithmetic operations or anything else that
 	// modifies eflags.
 	// LAB 4: Your code here.
 
+	addl $4, %esp 
+	popfl
+
 	// Switch back to the adjusted trap-time stack.
 	// LAB 4: Your code here.
 
+	popl %esp
+
 	// Return to re-execute the instruction that faulted.
 	// LAB 4: Your code here.
+
+	ret
diff --git a/lib/pgfault.c b/lib/pgfault.c
index a975518..a13aced 100644
--- a/lib/pgfault.c
+++ b/lib/pgfault.c
@@ -29,7 +29,12 @@ set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
 	if (_pgfault_handler == 0) {
 		// First time through!
 		// LAB 4: Your code here.
-		panic("set_pgfault_handler not implemented");
+		int err = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U);
+		if (err < 0) {
+			panic("sys_page_alloc: %e", err);
+		}
+		sys_env_set_pgfault_upcall(0, _pgfault_upcall);
+		//panic("set_pgfault_handler not implemented");
 	}
 
 	// Save handler pointer for assembly to call.
diff --git a/user/yield.c b/user/yield.c
index 6f45bdb..99318d9 100644
--- a/user/yield.c
+++ b/user/yield.c
@@ -7,11 +7,11 @@ umain(int argc, char **argv)
 {
 	int i;
 
-	cprintf("Hello, I am environment %08x.\n", thisenv->env_id);
+	cprintf("Hello, I am environment %08x, cpu %d.\n", thisenv->env_id, thisenv->env_cpunum);
 	for (i = 0; i < 5; i++) {
 		sys_yield();
-		cprintf("Back in environment %08x, iteration %d.\n",
-			thisenv->env_id, i);
+		cprintf("Back in environment %08x, iteration %d, cpu %d.\n",
+			thisenv->env_id, i, thisenv->env_cpunum);
 	}
-	cprintf("All done in environment %08x.\n", thisenv->env_id);
+	cprintf("All done in environment %08x, cpu %d.\n", thisenv->env_id, thisenv->env_cpunum);
 }
