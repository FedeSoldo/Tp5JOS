diff --git a/TP4.md b/TP4.md
new file mode 100644
index 0000000..3b73980
--- /dev/null
+++ b/TP4.md
@@ -0,0 +1,5 @@
+# Parte 1
+
+- Se recomienda leer la función diskaddr() en el archivo fs/bc.c. ¿Qué es super->s_nblocks?
+
+	Super es el superbloque. En este caso lo que se consulta es la cantidad de bloques que contiene el superbloque. Se está usando en la función de diskaddr para hacer cierto chequeo de sanidad.
diff --git a/__pycache__/gradelib.cpython-36.pyc b/__pycache__/gradelib.cpython-36.pyc
index 7f5c571..a0b46a6 100644
Binary files a/__pycache__/gradelib.cpython-36.pyc and b/__pycache__/gradelib.cpython-36.pyc differ
diff --git a/fs/bc.c b/fs/bc.c
index ec59cfb..f953847 100644
--- a/fs/bc.c
+++ b/fs/bc.c
@@ -51,6 +51,14 @@ bc_pgfault(struct UTrapframe *utf)
 	//
 	// LAB 5: you code here:
 
+	//Primero redondeo.
+	addr = ROUNDDOWN(addr, PGSIZE);
+	//Alocamos la pagina.
+	sys_page_alloc(0, addr, PTE_W|PTE_U|PTE_P);
+	//Leemos del disco.
+	if ((r = ide_read(blockno*BLKSECTS, addr, BLKSECTS)) < 0)
+		panic("Falla ide_read");
+
 	// Clear the dirty bit for the disk block page since we just read the
 	// block from disk
 	if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) <
@@ -75,12 +83,27 @@ void
 flush_block(void *addr)
 {
 	uint32_t blockno = ((uint32_t) addr - DISKMAP) / BLKSIZE;
+	int r;
 
 	if (addr < (void *) DISKMAP || addr >= (void *) (DISKMAP + DISKSIZE))
 		panic("flush_block of bad va %08x", addr);
 
 	// LAB 5: Your code here.
-	panic("flush_block not implemented");
+
+	//Redondeamos la direccion.
+	addr = ROUNDDOWN(addr, PGSIZE);
+	//Chequeamos que este mapeada y el dirty bit en 1.
+	if (va_is_mapped(addr) && va_is_dirty(addr))
+	{
+		//Escribimos en el bloque correspondiente.
+		ide_write(BLKSECTS * blockno, addr, BLKSECTS);
+
+		//Limpiamos el dirty bit.
+		if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] & PTE_SYSCALL)) <
+				0)
+			panic("in bc_pgfault, sys_page_map: %e", r);
+		//panic("flush_block not implemented");
+		}
 }
 
 // Test that the block cache works, by smashing the superblock and
diff --git a/fs/fs.c b/fs/fs.c
index 875f451..c134073 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -62,7 +62,16 @@ alloc_block(void)
 	// super->s_nblocks blocks in the disk altogether.
 
 	// LAB 5: Your code here.
-	panic("alloc_block not implemented");
+
+	uint32_t blockno;
+
+	for (blockno = 0; blockno < super->s_nblocks; blockno++)
+		if (block_is_free(blockno)) {
+			bitmap[blockno / 32] &= ~(1 << (blockno % 32));
+			flush_block(bitmap + blockno / 32);
+			return blockno;
+		}
+	//panic("alloc_block not implemented");
 	return -E_NO_DISK;
 }
 
@@ -133,7 +142,36 @@ static int
 file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
 {
 	// LAB 5: Your code here.
-	panic("file_block_walk not implemented");
+
+	if (filebno < NDIRECT) { // Se encuentra en el bloque directo
+		*ppdiskbno = f->f_direct + filebno;
+		return 0;
+	}
+
+	else if (filebno >= NDIRECT && filebno < NDIRECT + NINDIRECT) { // buscamos en el bloque indirecto
+		if (!f->f_indirect) { // si no hay bloque indirecto
+			if (!alloc)
+				return -E_NOT_FOUND;
+
+			int block = alloc_block();	// Lo creamos
+			if (block < 0)
+				return -E_NO_DISK;
+			else
+				f->f_indirect = block;
+
+			// Limpio el bloque
+			memset(diskaddr(f->f_indirect), 0, BLKSIZE);
+		}
+		// Y teniendo el bloque...
+		uint32_t* block_bc = (uint32_t*)diskaddr(f->f_indirect);
+		*ppdiskbno = block_bc + (filebno - NDIRECT);
+		return 0;
+	}
+
+	else	return -E_INVAL;   // filebno >= NDIRECT + NINDIRECT (fuera de rango)
+
+
+	//panic("file_block_walk not implemented");
 }
 
 // Set *blk to the address in memory where the filebno'th
@@ -148,7 +186,25 @@ int
 file_get_block(struct File *f, uint32_t filebno, char **blk)
 {
 	// LAB 5: Your code here.
-	panic("file_get_block not implemented");
+
+	int err;
+	uint32_t *ppdiskbno;
+
+	err = file_block_walk(f, filebno, &ppdiskbno, 1);
+	if (err)	return err;
+
+	if (!*ppdiskbno) { // Si no hay bloque, lo creamos
+		int block;
+		block = alloc_block();
+		if (block < 0)
+			return -E_NO_DISK;
+		*ppdiskbno = block;
+	}
+
+	*blk = diskaddr(*ppdiskbno);
+	return 0;
+
+	//panic("file_get_block not implemented");
 }
 
 // Try to find a file named "name" in dir.  If so, set *file to it.
diff --git a/fs/serv.c b/fs/serv.c
index f38153b..9b79c43 100644
--- a/fs/serv.c
+++ b/fs/serv.c
@@ -222,7 +222,21 @@ serve_read(envid_t envid, union Fsipc *ipc)
 		        req->req_n);
 
 	// Lab 5: Your code here:
-	return 0;
+
+	int err;
+	struct OpenFile *of;
+	if ((err = openfile_lookup(envid, req->req_fileid, &of)) < 0) {
+		return err;
+	}
+
+	ssize_t cant_bits;
+	if ((cant_bits = file_read(of->o_file, ret->ret_buf, req->req_n, of->o_fd->fd_offset)) < 0) {
+		return cant_bits;
+	}
+
+	of->o_fd->fd_offset += cant_bits;
+	return cant_bits;
+
 }
 
 
@@ -240,7 +254,22 @@ serve_write(envid_t envid, struct Fsreq_write *req)
 		        req->req_n);
 
 	// LAB 5: Your code here.
-	panic("serve_write not implemented");
+
+	int err;
+	struct OpenFile *of;
+	if ((err = openfile_lookup(envid, req->req_fileid, &of)) < 0) {
+		return err;
+	}
+
+	int cant_bits;
+	if ((cant_bits = file_write(of->o_file,	req->req_buf, req->req_n,	of->o_fd->fd_offset)) < 0) {
+		return cant_bits;
+	}
+	
+	of->o_fd->fd_offset += cant_bits;
+	return cant_bits;
+
+	//panic("serve_write not implemented");
 }
 
 // Stat ipc->stat.req_fileid.  Return the file's struct Stat to the
diff --git a/kern/env.c b/kern/env.c
index b31d166..631ec2b 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -415,7 +415,7 @@ env_create(uint8_t *binary, enum EnvType type)
 	// If this is the file server (type == ENV_TYPE_FS) give it I/O
 	// privileges.
 	// LAB 5: Your code here.
-
+	if (type == ENV_TYPE_FS) newProcess->env_tf.tf_eflags |= FL_IOPL_3;
 }
 
 //
diff --git a/kern/syscall.c b/kern/syscall.c
index 4bf522b..2675f16 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -142,7 +142,16 @@ sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 	// LAB 5: Your code here.
 	// Remember to check whether the user has supplied us with a good
 	// address!
-	panic("sys_env_set_trapframe not implemented");
+
+	struct Env *e;
+	int ret = envid2env(envid, &e, 1);
+	if (ret < 0) return -E_BAD_ENV;
+	user_mem_assert(e, tf, sizeof(struct Trapframe), PTE_U); //Chequeamos que podamos acceder a ese rango de memoria con este env.
+	e->env_tf = *tf;
+	e->env_tf.tf_eflags |= FL_IF; //Habilitamos interrupts.
+	e->env_tf.tf_cs = GD_UT | 3; 
+	return 0;
+	//panic("sys_env_set_trapframe not implemented");
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -467,6 +476,9 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 	case SYS_env_set_pgfault_upcall:
 		return sys_env_set_pgfault_upcall(a1, (void*)a2);
 
+	case SYS_env_set_trapframe:
+		return sys_env_set_trapframe(a1, (void *)a2);
+
 	default:
 		return -E_INVAL;
 	}
diff --git a/kern/trap.c b/kern/trap.c
index 1bdb967..d30767e 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -92,6 +92,21 @@ trap_init(void)
 	void handler19(void);
 
 	void handler32(void);
+	void handler33(void);
+	void handler34(void);
+	void handler35(void);
+	void handler36(void);
+	void handler37(void);
+	void handler38(void);
+	void handler39(void);
+	void handler40(void);
+	void handler41(void);
+	void handler42(void);
+	void handler43(void);
+	void handler44(void);
+	void handler45(void);
+	void handler46(void);
+	void handler47(void);
 
 	void handler48(void);
 
@@ -290,6 +305,16 @@ trap_dispatch(struct Trapframe *tf)
 	// Handle keyboard and serial interrupts.
 	// LAB 5: Your code here.
 
+	if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD) {
+		kbd_intr();
+		return;
+	}
+
+	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SERIAL) {
+		serial_intr();
+		return;
+	}
+
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
 	if (tf->tf_cs == GD_KT)
diff --git a/kern/trapentry.S b/kern/trapentry.S
index ea3f5c7..7fb5c57 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -76,6 +76,21 @@ manual de Intel. Ademas uso la info que hay en inc/trap.h
 	TRAPHANDLER_NOEC(handler19, 19)
 
 	TRAPHANDLER_NOEC(handler32, 32)
+	TRAPHANDLER_NOEC(handler33, 33)
+	TRAPHANDLER_NOEC(handler34, 34)
+	TRAPHANDLER_NOEC(handler35, 35)
+	TRAPHANDLER_NOEC(handler36, 36)
+	TRAPHANDLER_NOEC(handler37, 37)
+	TRAPHANDLER_NOEC(handler38, 38)
+	TRAPHANDLER_NOEC(handler39, 39)
+	TRAPHANDLER_NOEC(handler40, 40)
+	TRAPHANDLER_NOEC(handler41, 41)
+	TRAPHANDLER_NOEC(handler42, 42)
+	TRAPHANDLER_NOEC(handler43, 43)
+	TRAPHANDLER_NOEC(handler44, 44)
+	TRAPHANDLER_NOEC(handler45, 45)
+	TRAPHANDLER_NOEC(handler46, 46)
+	TRAPHANDLER_NOEC(handler47, 47)
 
 	TRAPHANDLER_NOEC(handler48, 48)
 
diff --git a/lib/file.c b/lib/file.c
index f2e0b45..1b7f472 100644
--- a/lib/file.c
+++ b/lib/file.c
@@ -141,7 +141,16 @@ devfile_write(struct Fd *fd, const void *buf, size_t n)
 	// remember that write is always allowed to write *fewer*
 	// bytes than requested.
 	// LAB 5: Your code here
-	panic("devfile_write not implemented");
+
+	fsipcbuf.write.req_fileid = fd->fd_file.id;
+	fsipcbuf.write.req_n = n;
+
+	size_t max_written = sizeof(fsipcbuf.write.req_buf);
+	memmove(fsipcbuf.write.req_buf, buf, MIN(max_written, n));
+
+	return fsipc(FSREQ_WRITE, NULL);
+
+	//panic("devfile_write not implemented");
 }
 
 static int
diff --git a/lib/fork.c b/lib/fork.c
index 39f1413..1f5db17 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -67,14 +67,15 @@ duppage(envid_t envid, unsigned pn)
 	//Calculo la direccion a partir del numero de pagina.
 	void *addr = (void*) (pn*PGSIZE);
 
-	if ((uvpt[pn] & PTE_W) || (uvpt[pn] & PTE_COW))
-	{
-		if (sys_page_map(0, addr, envid, addr, PTE_COW|PTE_U|PTE_P) < 0)
-			panic("Error 1");
-		if (sys_page_map(0, addr, 0, addr, PTE_COW|PTE_U|PTE_P) < 0)
-			panic("Error 2");
-	}
-	else sys_page_map(0, addr, envid, addr, PTE_U|PTE_P);
+	if (uvpt[pn] & PTE_SHARE) sys_page_map(0, addr, envid, addr, uvpt[pn]&PTE_SYSCALL); //Copiamos directo porque tiene activado el share.
+	else if ((uvpt[pn] & PTE_W) || (uvpt[pn] & PTE_COW))
+		{
+			if (sys_page_map(0, addr, envid, addr, PTE_COW|PTE_U|PTE_P) < 0)
+				panic("Error 1");
+			if (sys_page_map(0, addr, 0, addr, PTE_COW|PTE_U|PTE_P) < 0)
+				panic("Error 2");
+		}
+		else sys_page_map(0, addr, envid, addr, PTE_U|PTE_P);
 
 	//panic("duppage not implemented");
 	return 0;
diff --git a/lib/spawn.c b/lib/spawn.c
index 0858caf..bbab0d1 100644
--- a/lib/spawn.c
+++ b/lib/spawn.c
@@ -323,5 +323,25 @@ static int
 copy_shared_pages(envid_t child)
 {
 	// LAB 5: Your code here.
+
+  int pn, r;
+
+    for (int i = 0; i < NPDENTRIES; i++)
+    {
+      for (int j = 0; j < NPTENTRIES; j++)
+      {
+        pn = i * NPDENTRIES + j;
+        pde_t actual_PDE = uvpd[i];
+        if ((actual_PDE | PTE_P) != actual_PDE) continue;
+        pte_t actual_PTE = uvpt[pn];
+        if (pn * PGSIZE < UTOP && actual_PDE && actual_PTE)
+        {
+          if (actual_PTE & PTE_SHARE)
+          {
+            if ((r = sys_page_map(0, (void*)(pn * PGSIZE), child, (void*)(pn * PGSIZE), actual_PTE & PTE_SYSCALL)) < 0) return r;
+          }
+        }
+      }
+    }
 	return 0;
 }
diff --git a/user/sh.c b/user/sh.c
index 8ec285e..2c40310 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -55,7 +55,14 @@ again:
 			// then close the original 'fd'.
 
 			// LAB 5: Your code here.
-			panic("< redirection not implemented");
+
+			if ((fd = open(t, O_RDONLY)) < 0) {
+				exit();
+			}
+			if (fd != 0) {
+				dup(fd, 0);
+				close(fd);
+			}
 			break;
 
 		case '>':  // Output redirection
